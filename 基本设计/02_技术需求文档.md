# VoiceGrow 技术需求文档

> 版本: v1.1
> 更新日期: 2026-01-12

---

## 1. 技术栈选型

### 1.1 总体技术架构

```
┌─────────────────────────────────────────────────────────────┐
│              小爱音箱 (open-xiaoai Client)                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                   Rust Client                         │  │
│  │  • 麦克风音频流转发                                    │  │
│  │  • 设备事件传输（语音识别结果、播放状态）              │  │
│  │  • 执行服务端命令（脚本执行、音频播放）                │  │
│  └──────────────────────────────────────────────────────┘  │
│                         │ WebSocket (端口 4399)             │
└─────────────────────────┼───────────────────────────────────┘
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                    VoiceGrow Server                          │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐       │
│  │ ASR      │ │ 意图识别 │ │ 内容管理 │ │ TTS      │       │
│  │ Whisper  │ │ NLU      │ │ Content  │ │ Azure    │       │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘       │
│  ┌──────────┐ ┌──────────┐                                  │
│  │ LLM对话  │ │ 会话管理 │                                  │
│  │ OpenAI   │ │ Session  │                                  │
│  └──────────┘ └──────────┘                                  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 开发语言与框架

| 组件 | 语言/框架 | 版本要求 | 说明 |
|-----|----------|---------|-----|
| 服务端主程序 | Python | >= 3.10 | 主要开发语言 |
| Web框架 | FastAPI | >= 0.100 | 高性能异步框架 |
| 客户端 | Rust | - | **使用 open-xiaoai 现有客户端** |
| ASR引擎 | faster-whisper | >= 0.10 | Whisper优化版本 |
| 数据库 | MySQL | >= 8.0 | 元数据存储 |
| 对象存储 | MinIO | latest | 音频文件存储 |
| 缓存 | Redis (可选) | >= 7.0 | 会话缓存 |

### 1.3 外部服务依赖

| 服务 | 提供商 | 用途 | 备选方案 |
|-----|-------|-----|---------|
| TTS | Azure Speech | 语音合成 | 阿里云TTS、edge-tts |
| LLM | OpenAI GPT-4 | 智能对话 | Claude、通义千问 |
| LLM (备选) | 阿里通义千问 | 智能对话 | 国内访问更稳定 |

---

## 2. 客户端说明（open-xiaoai）

### 2.1 项目来源

客户端使用 **open-xiaoai** 开源项目，无需自行开发。

- **项目地址**: https://github.com/idootop/open-xiaoai
- **客户端文档**: https://github.com/idootop/open-xiaoai/blob/main/packages/client-rust/README.md

### 2.2 支持的设备型号

⚠️ **仅支持以下两款音箱型号，其他型号不兼容：**

| 型号 | 产品名称 |
|-----|---------|
| **LX06** | 小爱音箱 Pro |
| **OH2P** | Xiaomi Smart Speaker Pro |

### 2.3 客户端功能

open-xiaoai Rust 客户端提供以下核心功能：

| 功能 | 说明 |
|-----|-----|
| 麦克风音频流转发 | 将音箱麦克风采集的音频实时转发到服务端 |
| 设备事件传输 | 传输语音识别结果、播放状态等设备事件 |
| 服务端命令执行 | 执行服务端下发的脚本、音频播放、系统更新等命令 |
| WebSocket通信 | 与服务端保持实时双向通信（默认端口 4399） |

### 2.4 客户端部署步骤

#### 2.4.1 前置条件

1. **刷机**: 需要先对小爱音箱进行固件刷写
2. **SSH访问**: 刷机后需要能够通过SSH连接到音箱

#### 2.4.2 安装步骤

```bash
# 1. SSH连接到音箱
ssh root@<音箱IP>

# 2. 创建工作目录
mkdir -p /data/open-xiaoai

# 3. 配置服务器地址（将 YOUR_SERVER_IP 替换为实际服务端地址）
echo "ws://YOUR_SERVER_IP:4399" > /data/open-xiaoai/server.txt

# 4. 运行初始化脚本
curl -fsSL https://raw.githubusercontent.com/idootop/open-xiaoai/main/scripts/init.sh | sh
```

#### 2.4.3 手动编译（可选）

如需自行编译客户端：

```bash
# 安装 Rust 和 cross 编译工具
cargo install cross

# 编译 ARM 架构二进制文件
cross build --release --target armv7-unknown-linux-gnueabihf

# 将编译产物复制到音箱
scp target/armv7-unknown-linux-gnueabihf/release/open-xiaoai root@<音箱IP>:/data/open-xiaoai/

# 在音箱上运行
chmod +x /data/open-xiaoai/open-xiaoai
/data/open-xiaoai/open-xiaoai ws://YOUR_SERVER_IP:4399
```

### 2.5 重要注意事项

⚠️ **安全警告**：

1. open-xiaoai 是一个**基础演示程序**，不包含：
   - 设备管理功能
   - 身份认证机制
   - 通信加密
   - 音频压缩

2. 客户端支持**任意脚本执行**能力，因此：
   - 必须完全信任配置的服务端地址
   - 建议仅在内网环境使用
   - 生产环境需自行增加安全措施

### 2.6 唤醒词说明

open-xiaoai 项目支持自定义唤醒词功能，可通过以下方式实现：

- 保留原有"小爱同学"唤醒词
- 或集成 Porcupine/Snowboy 等唤醒词引擎（需在服务端或客户端实现）

**MVP阶段建议**：先使用原有"小爱同学"唤醒词，后续再扩展自定义唤醒词功能。

---

## 3. 服务端技术要求

### 3.1 项目结构

```
server/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI应用入口
│   ├── config.py            # 配置管理
│   ├── api/                 # API路由
│   │   ├── __init__.py
│   │   ├── websocket.py     # WebSocket端点（端口4399）
│   │   ├── audio.py         # 音频处理API
│   │   └── content.py       # 内容管理API
│   ├── core/                # 核心业务逻辑
│   │   ├── __init__.py
│   │   ├── asr.py           # 语音识别
│   │   ├── nlu.py           # 自然语言理解
│   │   ├── tts.py           # 语音合成
│   │   ├── llm.py           # LLM对话
│   │   └── router.py        # 意图路由
│   ├── services/            # 功能服务
│   │   ├── __init__.py
│   │   ├── story.py         # 故事服务
│   │   ├── music.py         # 音乐服务
│   │   ├── english.py       # 英语学习服务
│   │   └── chat.py          # 对话服务
│   ├── models/              # 数据模型
│   │   ├── __init__.py
│   │   ├── content.py       # 内容模型
│   │   ├── session.py       # 会话模型
│   │   └── user.py          # 用户模型
│   └── utils/               # 工具函数
│       ├── __init__.py
│       ├── audio.py         # 音频处理工具
│       └── cache.py         # 缓存工具
├── content/                 # 内容文件存储
├── tests/                   # 测试
├── requirements.txt
└── pyproject.toml
```

### 3.2 语音识别 (ASR)

#### 3.2.1 技术方案: faster-whisper

```python
from faster_whisper import WhisperModel

class ASRService:
    def __init__(self):
        # 使用small模型平衡速度和准确率
        self.model = WhisperModel(
            "small",
            device="cpu",      # 或 "cuda"
            compute_type="int8"  # 量化加速
        )

    def transcribe(self, audio_path: str) -> str:
        segments, info = self.model.transcribe(
            audio_path,
            language="zh",
            beam_size=5,
            vad_filter=True
        )
        return "".join([seg.text for seg in segments])
```

#### 3.2.2 模型选择

| 模型 | 大小 | 速度 | 准确率 | 推荐场景 |
|-----|-----|-----|-------|---------|
| tiny | 39MB | 最快 | 一般 | 资源受限 |
| base | 74MB | 快 | 较好 | 开发测试 |
| small | 244MB | 中等 | 好 | **推荐MVP** |
| medium | 769MB | 慢 | 很好 | 高准确率需求 |

#### 3.2.3 性能优化

```python
# 配置优化选项
ASR_CONFIG = {
    'model_size': 'small',
    'device': 'cpu',
    'compute_type': 'int8',     # CPU量化
    'num_workers': 2,           # 并行处理
    'beam_size': 5,
    'vad_filter': True,         # VAD过滤静音
    'vad_parameters': {
        'min_silence_duration_ms': 500
    }
}
```

### 3.3 意图识别 (NLU)

#### 3.3.1 意图分类

```python
from enum import Enum

class Intent(Enum):
    # 故事相关
    PLAY_STORY = "play_story"
    PLAY_STORY_CATEGORY = "play_story_category"
    PLAY_STORY_BY_NAME = "play_story_by_name"

    # 音乐相关
    PLAY_MUSIC = "play_music"
    PLAY_MUSIC_CATEGORY = "play_music_category"
    PLAY_MUSIC_BY_NAME = "play_music_by_name"

    # 播放控制
    CONTROL_PAUSE = "control_pause"
    CONTROL_RESUME = "control_resume"
    CONTROL_NEXT = "control_next"
    CONTROL_PREVIOUS = "control_previous"
    CONTROL_VOLUME = "control_volume"

    # 英语学习
    ENGLISH_LEARN = "english_learn"
    ENGLISH_WORD = "english_word"
    ENGLISH_FOLLOW = "english_follow"

    # 对话
    CHAT = "chat"

    # 系统
    SYSTEM_TIME = "system_time"
    SYSTEM_WEATHER = "system_weather"

    # 未知
    UNKNOWN = "unknown"
```

#### 3.3.2 意图识别实现

```python
# 基于规则+LLM的混合方案
class NLUService:
    def __init__(self):
        self.rules = self._load_rules()

    def recognize(self, text: str) -> tuple[Intent, dict]:
        # 1. 先用规则匹配
        intent, slots = self._rule_match(text)
        if intent != Intent.UNKNOWN:
            return intent, slots

        # 2. 规则无法匹配时使用LLM
        return self._llm_classify(text)

    def _rule_match(self, text: str) -> tuple[Intent, dict]:
        # 故事播放规则
        story_patterns = [
            (r'(讲|播放|来)(个|一个)?故事', Intent.PLAY_STORY),
            (r'(我要)?听(.+)的故事', Intent.PLAY_STORY_BY_NAME),
            (r'播放(睡前|童话|寓言)故事', Intent.PLAY_STORY_CATEGORY),
        ]
        # ... 更多规则
```

### 3.4 语音合成 (TTS)

#### 3.4.1 Azure Speech TTS

```python
import azure.cognitiveservices.speech as speechsdk

class TTSService:
    def __init__(self):
        self.config = speechsdk.SpeechConfig(
            subscription=os.getenv('AZURE_SPEECH_KEY'),
            region=os.getenv('AZURE_SPEECH_REGION')
        )
        # 设置中文女声
        self.config.speech_synthesis_voice_name = 'zh-CN-XiaoxiaoNeural'

    async def synthesize(self, text: str) -> bytes:
        synthesizer = speechsdk.SpeechSynthesizer(
            speech_config=self.config,
            audio_config=None  # 返回音频数据而非播放
        )
        result = synthesizer.speak_text_async(text).get()
        return result.audio_data

    async def synthesize_stream(self, text: str):
        """流式合成，用于实时播放"""
        # 实现流式TTS
        pass
```

#### 3.4.2 推荐音色

| 语言 | 音色名称 | 特点 |
|-----|---------|-----|
| 中文 | zh-CN-XiaoxiaoNeural | 温暖、亲切，适合儿童 |
| 中文 | zh-CN-YunxiNeural | 男声，适合讲故事 |
| 英文 | en-US-JennyNeural | 清晰、标准美式发音 |
| 英文 | en-GB-SoniaNeural | 英式发音 |

### 3.5 LLM对话

#### 3.5.1 OpenAI集成

```python
from openai import AsyncOpenAI

class LLMService:
    def __init__(self):
        self.client = AsyncOpenAI()
        self.system_prompt = """你是一个儿童AI助手，名字叫"小声"。

请遵循以下规则：
1. 使用简单、易懂的语言
2. 回答要简短，适合语音播放（不超过100字）
3. 保持友好、温暖的语气
4. 不讨论任何不适合儿童的话题
5. 对于不确定的问题，诚实说"我不太确定"
6. 鼓励好奇心和学习"""

    async def chat(self, message: str, history: list = None) -> str:
        messages = [{"role": "system", "content": self.system_prompt}]

        if history:
            messages.extend(history)

        messages.append({"role": "user", "content": message})

        response = await self.client.chat.completions.create(
            model="gpt-4-turbo-preview",
            messages=messages,
            max_tokens=150,
            temperature=0.7
        )

        return response.choices[0].message.content
```

#### 3.5.2 内容安全过滤

```python
class ContentFilter:
    def __init__(self):
        self.blocked_words = self._load_blocked_words()

    def filter(self, text: str) -> tuple[bool, str]:
        """
        返回: (is_safe, filtered_text)
        """
        # 1. 关键词过滤
        for word in self.blocked_words:
            if word in text:
                return False, "这个问题我不太方便回答哦"

        # 2. 可选: 使用AI内容审核API

        return True, text
```

### 3.6 内容管理

#### 3.6.1 存储架构

VoiceGrow 采用 **MinIO + MySQL** 架构进行内容管理：

- **MinIO**: 存储音频文件（故事、音乐、英语学习音频）
- **MySQL**: 存储内容元数据，支持检索和管理

```
┌─────────────────────────────────────────────────────────────┐
│                    内容管理架构                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────┐    检索元数据    ┌─────────────────────┐  │
│  │             │ ───────────────> │                     │  │
│  │  VoiceGrow  │                  │      MySQL          │  │
│  │   Server    │ <─────────────── │   (元数据存储)       │  │
│  │             │   返回MinIO路径   │                     │  │
│  └──────┬──────┘                  └─────────────────────┘  │
│         │                                                   │
│         │ 返回预签名URL或直接路径                            │
│         ▼                                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                     MinIO                            │   │
│  │              (对象存储 - 音频文件)                    │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │            voicegrow-bucket                 │    │   │
│  │  │  ├── stories/    (故事音频)                 │    │   │
│  │  │  ├── music/      (音乐文件)                 │    │   │
│  │  │  ├── english/    (英语学习音频)             │    │   │
│  │  │  └── covers/     (封面图片)                 │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 3.6.2 数据库模型 (MySQL)

```python
from sqlalchemy import Column, Integer, String, Text, DateTime, JSON, ForeignKey, Index
from sqlalchemy.orm import declarative_base
from datetime import datetime

Base = declarative_base()

class Content(Base):
    """内容元数据表"""
    __tablename__ = 'contents'

    id = Column(Integer, primary_key=True, autoincrement=True)
    type = Column(String(20), nullable=False)         # story, music, english
    category = Column(String(50), nullable=False)     # bedtime, fairy_tale, etc.
    title = Column(String(200), nullable=False)
    description = Column(Text)
    duration = Column(Integer)                         # 时长（秒）
    minio_path = Column(String(500), nullable=False)  # MinIO对象路径
    cover_path = Column(String(500))                   # 封面图MinIO路径
    metadata = Column(JSON)                            # 额外元数据
    play_count = Column(Integer, default=0)
    age_min = Column(Integer, default=0)               # 最小适合年龄
    age_max = Column(Integer, default=12)              # 最大适合年龄
    tags = Column(String(500))                         # 标签，逗号分隔
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # 索引优化
    __table_args__ = (
        Index('idx_type_category', 'type', 'category'),
        Index('idx_title', 'title'),
    )

class PlayHistory(Base):
    """播放历史表"""
    __tablename__ = 'play_history'

    id = Column(Integer, primary_key=True, autoincrement=True)
    device_id = Column(String(100))                    # 设备标识
    content_id = Column(Integer, ForeignKey('contents.id'))
    played_at = Column(DateTime, default=datetime.utcnow)
    progress = Column(Integer, default=0)              # 播放进度（秒）
    completed = Column(Integer, default=0)             # 是否播放完成
```

#### 3.6.3 MinIO 客户端

```python
from minio import Minio
from minio.error import S3Error
import os

class MinIOService:
    def __init__(self):
        self.client = Minio(
            endpoint=os.getenv('MINIO_ENDPOINT', 'localhost:9000'),
            access_key=os.getenv('MINIO_ACCESS_KEY'),
            secret_key=os.getenv('MINIO_SECRET_KEY'),
            secure=os.getenv('MINIO_SECURE', 'false').lower() == 'true'
        )
        self.bucket_name = os.getenv('MINIO_BUCKET', 'voicegrow-bucket')
        self._ensure_bucket()

    def _ensure_bucket(self):
        """确保存储桶存在"""
        if not self.client.bucket_exists(self.bucket_name):
            self.client.make_bucket(self.bucket_name)

    def get_presigned_url(self, object_path: str, expires: int = 3600) -> str:
        """获取预签名URL用于音频播放"""
        from datetime import timedelta
        return self.client.presigned_get_object(
            self.bucket_name,
            object_path,
            expires=timedelta(seconds=expires)
        )

    def get_direct_url(self, object_path: str) -> str:
        """获取直接访问URL（需配置公开访问策略）"""
        endpoint = os.getenv('MINIO_ENDPOINT', 'localhost:9000')
        protocol = 'https' if os.getenv('MINIO_SECURE', 'false').lower() == 'true' else 'http'
        return f"{protocol}://{endpoint}/{self.bucket_name}/{object_path}"

    def upload_file(self, file_path: str, object_path: str) -> bool:
        """上传文件到MinIO"""
        try:
            self.client.fput_object(self.bucket_name, object_path, file_path)
            return True
        except S3Error as e:
            print(f"MinIO upload error: {e}")
            return False
```

#### 3.6.4 内容检索服务

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func

class ContentService:
    def __init__(self, db: AsyncSession, minio: MinIOService):
        self.db = db
        self.minio = minio

    async def search(
        self,
        content_type: str = None,
        category: str = None,
        keyword: str = None,
        limit: int = 20
    ) -> list[dict]:
        """搜索内容并返回带MinIO URL的结果"""
        query = select(Content)

        if content_type:
            query = query.where(Content.type == content_type)
        if category:
            query = query.where(Content.category == category)
        if keyword:
            query = query.where(Content.title.contains(keyword))

        query = query.limit(limit)
        result = await self.db.execute(query)
        contents = result.scalars().all()

        # 转换为包含MinIO URL的响应
        return [self._to_response(content) for content in contents]

    async def get_random(
        self,
        content_type: str,
        category: str = None
    ) -> dict:
        """获取随机内容"""
        query = select(Content).where(Content.type == content_type)
        if category:
            query = query.where(Content.category == category)
        query = query.order_by(func.rand()).limit(1)  # MySQL使用rand()

        result = await self.db.execute(query)
        content = result.scalar()

        if content:
            return self._to_response(content)
        return None

    def _to_response(self, content: Content) -> dict:
        """转换为API响应格式，包含MinIO URL"""
        return {
            "id": content.id,
            "type": content.type,
            "category": content.category,
            "title": content.title,
            "description": content.description,
            "duration": content.duration,
            "audio_url": self.minio.get_presigned_url(content.minio_path),
            "cover_url": self.minio.get_presigned_url(content.cover_path) if content.cover_path else None,
            "play_count": content.play_count,
            "tags": content.tags.split(',') if content.tags else []
        }
```

---

## 4. 通信协议

### 4.1 与 open-xiaoai 客户端通信

#### 4.1.1 WebSocket 端点

服务端需要在 **端口 4399** 提供 WebSocket 服务，与 open-xiaoai 客户端通信：

```
ws://server:4399
```

#### 4.1.2 消息格式（需适配 open-xiaoai 协议）

根据 open-xiaoai 客户端的实现，服务端需要处理以下类型的消息：

```python
# 客户端 -> 服务端：音频流
{
    "type": "audio_stream",
    "data": "<binary_audio_data>",  # 麦克风音频流
    "timestamp": 1704067200
}

# 客户端 -> 服务端：设备事件
{
    "type": "device_event",
    "event": "asr_result",          # 或 playback_status 等
    "data": {...},
    "timestamp": 1704067200
}

# 服务端 -> 客户端：播放音频
{
    "type": "play_audio",
    "url": "http://server/audio/xxx.mp3",
    "timestamp": 1704067201
}

# 服务端 -> 客户端：执行脚本
{
    "type": "execute_script",
    "script": "...",
    "timestamp": 1704067201
}

# 服务端 -> 客户端：TTS播放
{
    "type": "tts",
    "text": "好的，现在为你播放故事",
    "audio_data": "<base64_audio>",  # 或提供URL
    "timestamp": 1704067201
}
```

> ⚠️ **注意**: 具体消息格式需要参考 open-xiaoai 源码确认，上述仅为示意。

#### 4.1.3 交互流程

```
open-xiaoai Client                    VoiceGrow Server
       |                                     |
       |  1. WebSocket连接 (端口4399)        |
       |------------------------------------>|
       |                                     |
       |  2. 音频流转发                       |
       |------------------------------------>|
       |                                     | (ASR识别)
       |                                     | (NLU意图理解)
       |                                     | (业务处理)
       |                                     |
       |  3. 播放指令/TTS                    |
       |<------------------------------------|
       |                                     |
       |  (客户端执行播放)                    |
       |                                     |
```

### 4.2 REST API（内部管理）

#### 4.2.1 内容管理API

```yaml
# 获取内容列表
GET /api/content
Parameters:
  - type: story | music | english
  - category: string
  - page: int
  - size: int

# 获取单个内容
GET /api/content/{id}

# 获取音频文件
GET /api/audio/{path}
```

---

## 5. 部署架构

### 5.1 开发环境

```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  server:
    build: ./server
    ports:
      - "4399:4399"    # WebSocket for open-xiaoai client
      - "8000:8000"    # HTTP API
    volumes:
      - ./server:/app
    environment:
      - AZURE_SPEECH_KEY=${AZURE_SPEECH_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - MYSQL_HOST=mysql
      - MYSQL_PORT=3306
      - MYSQL_USER=voicegrow
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - MYSQL_DATABASE=voicegrow
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=${MINIO_ACCESS_KEY}
      - MINIO_SECRET_KEY=${MINIO_SECRET_KEY}
      - MINIO_BUCKET=voicegrow-bucket
    depends_on:
      - mysql
      - minio
    command: uvicorn app.main:app --reload --host 0.0.0.0

  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_DATABASE=voicegrow
      - MYSQL_USER=voicegrow
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql

  minio:
    image: minio/minio:latest
    ports:
      - "9000:9000"    # API
      - "9001:9001"    # Console
    environment:
      - MINIO_ROOT_USER=${MINIO_ACCESS_KEY}
      - MINIO_ROOT_PASSWORD=${MINIO_SECRET_KEY}
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"

volumes:
  mysql_data:
  minio_data:
```

### 5.2 生产部署

```
┌────────────────────────────────────────────┐
│     小爱音箱 Pro (LX06) / Smart Speaker    │
│              Pro (OH2P)                    │
│         (运行 open-xiaoai 客户端)           │
└──────────────────┬─────────────────────────┘
                   │ WebSocket (端口 4399)
                   ▼
┌────────────────────────────────────────────┐
│         VoiceGrow Server (Python)          │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐      │
│  │ ASR     │ │ NLU     │ │ TTS     │      │
│  │ Whisper │ │ Router  │ │ Azure   │      │
│  └─────────┘ └─────────┘ └─────────┘      │
│  ┌─────────┐ ┌─────────┐                  │
│  │ LLM     │ │ Content │                  │
│  │ OpenAI  │ │ Manager │                  │
│  └─────────┘ └─────────┘                  │
└──────────────────┬─────────────────────────┘
                   │
         ┌─────────┼─────────┐
         ▼         ▼         ▼
┌─────────────┐ ┌─────────┐ ┌─────────────┐
│   MySQL     │ │  MinIO  │ │   Redis     │
│ (元数据)    │ │(音频文件)│ │  (缓存)     │
└─────────────┘ └─────────┘ └─────────────┘
```

### 5.3 网络要求

| 端口 | 用途 | 说明 |
|-----|-----|-----|
| 4399 | WebSocket | open-xiaoai 客户端连接 |
| 8000 | HTTP API | 内容管理、音频文件服务 |

服务端需要与小爱音箱在同一局域网内，或通过内网穿透访问。

---

## 6. 测试要求

### 6.1 单元测试

```python
# tests/test_asr.py
import pytest
from app.core.asr import ASRService

class TestASR:
    @pytest.fixture
    def asr_service(self):
        return ASRService()

    def test_chinese_recognition(self, asr_service):
        result = asr_service.transcribe("test_audio/chinese.wav")
        assert "你好" in result

    def test_empty_audio(self, asr_service):
        result = asr_service.transcribe("test_audio/silence.wav")
        assert result == ""
```

### 6.2 集成测试

```python
# tests/test_integration.py
import pytest
from httpx import AsyncClient
from app.main import app

class TestIntegration:
    @pytest.mark.asyncio
    async def test_voice_to_response(self):
        async with AsyncClient(app=app) as client:
            # 上传音频
            with open("test_audio/play_story.wav", "rb") as f:
                response = await client.post(
                    "/api/audio/process",
                    files={"audio": f}
                )

            assert response.status_code == 200
            data = response.json()
            assert data["intent"] == "play_story"
```

### 6.3 性能测试

| 测试项 | 目标 | 测试方法 |
|-------|-----|---------|
| ASR延迟 | < 2s | 批量音频测试 |
| TTS延迟 | < 1s | 不同长度文本测试 |
| 并发处理 | 10并发 | 压力测试 |
| 内存占用 | < 512MB | 长时间运行监控 |

---

## 7. 环境变量配置

```bash
# .env.example

# Azure Speech Service
AZURE_SPEECH_KEY=your_azure_speech_key
AZURE_SPEECH_REGION=eastasia

# OpenAI
OPENAI_API_KEY=your_openai_api_key
OPENAI_MODEL=gpt-4-turbo-preview

# 备选: 阿里通义千问
DASHSCOPE_API_KEY=your_dashscope_api_key

# 服务配置
SERVER_HOST=0.0.0.0
WEBSOCKET_PORT=4399          # open-xiaoai 客户端连接端口
HTTP_PORT=8000               # HTTP API 端口
DEBUG=false

# MySQL 数据库
MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_USER=voicegrow
MYSQL_PASSWORD=your_mysql_password
MYSQL_DATABASE=voicegrow
DATABASE_URL=mysql+aiomysql://voicegrow:your_mysql_password@localhost:3306/voicegrow

# MinIO 对象存储
MINIO_ENDPOINT=localhost:9000
MINIO_ACCESS_KEY=your_minio_access_key
MINIO_SECRET_KEY=your_minio_secret_key
MINIO_BUCKET=voicegrow-bucket
MINIO_SECURE=false           # 生产环境设为 true

# Redis 缓存 (可选)
REDIS_URL=redis://localhost:6379/0
```

---

## 8. 依赖清单

### 8.1 Python依赖

```txt
# requirements.txt

# Web框架
fastapi>=0.100.0
uvicorn[standard]>=0.23.0
websockets>=11.0

# ASR
faster-whisper>=0.10.0

# TTS
azure-cognitiveservices-speech>=1.35.0

# LLM
openai>=1.10.0
dashscope>=1.14.0  # 通义千问备选

# 数据库 (MySQL)
sqlalchemy>=2.0.0
aiomysql>=0.2.0
PyMySQL>=1.1.0

# 对象存储 (MinIO)
minio>=7.2.0

# 缓存 (可选)
redis>=5.0.0

# 工具
python-dotenv>=1.0.0
pydantic>=2.0.0
numpy>=1.24.0

# 测试
pytest>=7.4.0
pytest-asyncio>=0.21.0
httpx>=0.25.0
```

### 8.2 系统依赖

```bash
# Ubuntu/Debian
apt-get install -y \
    ffmpeg \
    libsndfile1
```

---

## 附录A: open-xiaoai 参考资料

| 资源 | 链接 |
|-----|-----|
| 项目主页 | https://github.com/idootop/open-xiaoai |
| Rust客户端文档 | https://github.com/idootop/open-xiaoai/blob/main/packages/client-rust/README.md |
| 刷机教程 | 见项目Wiki |

## 附录B: 服务端需适配的 open-xiaoai 协议

由于 open-xiaoai 是独立项目，服务端开发时需要：

1. 阅读 open-xiaoai 源码，了解具体的 WebSocket 消息格式
2. 实现与 open-xiaoai 客户端兼容的通信协议
3. 处理客户端发送的音频流和设备事件
4. 下发正确格式的播放指令和TTS内容

建议在开发初期先搭建一个简单的 echo 服务，验证与 open-xiaoai 客户端的连通性。
